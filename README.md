### Базовая конфигурация

Инициализируем проект:

`npm init -y`

Добавляем директорию `src` и создаем в нем `index.js` файл

Устанавливаем `webpack` и `webpack cli`

`npm i -D webpack webpack cli`

устанавливаем как dev зависимости, потому что он будет использоваться только во время разработки 

то что получается в результате сборки `webpack` называется **bundle**

### Создаем webpack.config.js

В корневой директории создаем файл webpack.config.js

```
module.exports = {
  entry: // путь к точке входа в приложение, как правило это index.js файл
}
```

используем `path.resolve` чтобы наш путь правильно определялся во всех операционных системах

можно также сделать несколько entry поинтов:

```
module.exports = {
	entry: {
		helloWorld: path.resolve(__dirname, src, index.js),
		helloWorld2: path.resolve(__dirname, src, index2.js),
	}
}
```

в итоге создается 2 бандла с названиями: helloWorld.js, helloWorld2.js

### Output

```
module.exports = {

  entry: path.resolve(__dirname, 'src', 'index.js'),

  output: {  } // конфигурация того, куда и как сборка будет происходить
  
}
```

```
output: {
	filename: 'bundle.js'
}
```

Есть проблемы со статичным названием файла. Браузер кеширует js файл по названию и даже если мы внесли какие-либо изменения в бандл, но название файла не изменилось, он просто достанет файл из кеша. Чтобы решить эту проблему можно сделать следующим образом:

`filename: '[name].[contenthash].js'`

name - название entry поинта
contenthash - хеш от содержимого файла

### Переменные окружения

Можно использовать любой формат переменных окружения. Передать их при запуске в консоли, создать .env файл или задать их на уровне операционной системы.

например передаем при запуске в консоли: 

`webpack --env mode=development`

[Ссылка](https://webpack.js.org/guides/environment-variables/)

### Плагины и работа с HTML

В webpack существует механизм плагинов, которые добавляют дополнительный функционал. Этих плагинов большое количество, также мы сами можем их разрабатывать благодаря webpack api. 

Задача состоит в том, чтобы в HTML автоматически подставлялись скрипты, которые получаются в результате сборки webpack, т. е. бандлы. Для решения это задачи существует плагин: HtmlWebpackPlugin

ProgressPlugin - показывает прогресс сборки (не рекомендуется использовать в продакшене, так как сильно замедляет сборку)

В отличие от лоадеров, плагины позволяют выполнять задачи после сборки бандла. Эти задачи могут касаться как самого бандла, так и другого кода.


### Концепция лоадеров

Лоадеры представляют из себя некоторую цепочку об работчиков, через которую проходят файлы с тем или иным расширением. По тому расширению, которую мы указываем в лоадере, обработчик понимает какие файлы необходимо ему обработать и на выходе он их компилирует ts -> js, svg -> react component, scss -> css.

Но самое важное, это порядок выполнения лоадеров. Они начинают выполнятся с конца массива.

![image](</images/Pasted image 20240218101900.png>)

На данном примере сначала выполняется компиляция sccs в сss, потом компиляция css в commonJS и в самом конце получаем css js строки, которые попадают в бандл. Причем style loader можно заменить на какой-нибудь другой лоадер и получать не js строки, а например отдельные css файлы.

### Настраиваем typescript

Необходимо установить сам typescript и ts-loader для обработки ts файлов:

`npm install --save-dev typescript ts-loader`

чтобы typescript начал работать надо настроить tsconfig.

[Настройка tsconfig часть 1](https://habr.com/ru/articles/542234/)
[Настройка tsconfig часть 2](https://habr.com/ru/articles/557738/)

#### Resolve.extensions

Опция `resolve.extensions` в конфигурации Webpack используется для указания расширений файлов, которые Webpack будет автоматически разрешать при импорте модулей. Это делает импорты более краткими, так как не нужно указывать расширение файла каждый раз при использовании импорта.

Вот пример использования `resolve.extensions`:

`module.exports = {   // ... другие настройки ...    resolve: {     extensions: ['.tsx', '.ts', '.js'],   }, };`

В этом примере указаны расширения `.tsx`, `.ts` и `.js`. Теперь, при импорте модулей, Webpack будет автоматически искать файлы с этими расширениями и разрешать их без явного указания.

Например, если у вас есть файлы `example.tsx`, `example.ts` и `example.js`, и вы хотите импортировать их, вам не нужно указывать расширение в каждом импорте:

`// Без resolve.extensions import Example from './example'; // Неясно, какой файл выберется  // С resolve.extensions import Example from './example'; // Webpack автоматически разрешит example.tsx, затем example.ts, затем example.js`

Это упрощает код и делает его более читаемым. Однако, важно помнить, что использование слишком широкого списка расширений может замедлить процесс сборки, так как Webpack может потратить больше времени на разрешение модулей.

### Конфиг webpack на typescript

Установка:

`npm i -D @types/node @types/webpack ts-node`

заранее установим и типы для webpack-dev-server

`npm i -D @types/webpack-dev-server`

### Dev Server. Watch режим. Source Maps

Dev server позволяет сразу на какие-либо изменения в коде делать ребилд, чтобы все изменения отображались и было комфортно разрабатывать.

Есть три варианта работы в режиме dev сервера:

- webpack watch mode - это самый стандартный способ
- webpack dev server - это что-то среднее, конфигурируемый dev server
- webpack dev middleware - это продвинутый способ настройки dev server, когда прямо в node.js поднимается сервер, подключается middleware


Когда у нас на выходе из огромного количества js/ts файлов получается один финальный бандл не очень понятно как потом отслеживать ошибки, как понять где они произошли, как правильно отслеживать stack trace, смотреть в каком порядке были вызваны функции. И вот source map помогает понять в каком исходном виде был написан код.

### Промежуточные итоги

- сделали конфиг, в котором указали mode: development или production
- указали entry point, путь до входного файла
- настроили output, куда и как будет происходить сборка
- использовали плагины, самый важный это HtmlWebpackPlugin, который подставляет скрипты в index.html
- узнали про концепцию лоадеров, которые как-то обрабатывают файлы с разными расширениями
- настроили devtool
- настроили dev сервер

### React

Установка:

`npm i react react-dom @types/react @types/react-dom`

Если бы мы ранее не подключали ts-loader, который умеет работать с jsx, то нам бы пришлось подключать babel-loader.

### Стилизация. CSS + SCSS

Для обработки css файлов необходимо установить css-loader.

`npm i -D css-loader`

Добавляем лоадер в массив rules.

Также нам необходимо установить style-loader.

`npm i -D style-loader`

Для того чтобы работать с scss файлами необходимо установить sass и sass-loader.

`npm i -D sass sass-loader`

### MiniCssExtractPlugin

Документация webpack говорит, что для production сборки лучше использовать MiniCssExtractPlugin:

"Для производственных сборок рекомендуется извлекать CSS из вашего пакета, чтобы позже можно было использовать параллельную загрузку ресурсов CSS/JS. Этого можно достичь с помощью плагина mini-css-extract, поскольку он создает отдельные файлы css. Для режима разработки (включая webpack-dev-server) вы можете использовать style-loader, потому что он вводит CSS в DOM, используя несколько <style></style> и работает быстрее." [Ссылка](https://webpack.js.org/loaders/css-loader/#recommend)

Установка:

`npm i -D mini-css-extract-plugin`

### CSS modules

Проблема:
В большом проекте трудно следить за коллизиями селекторов.

![image](</images/Pasted image 20240222105552.png>)

Существует множество способов решения данной проблемы, но одной из популярных является БЭМ.

![image](<./images/Pasted image 20240222105512.png>)

modal - блок
content - элемент
open - модификатор

За счет этого практически гарантируется изоляция стилей, но не на 100 процентов, потому что опять же при каких-то условиях нейминга в больших проектах селекторы могут совпадать. Так же следует отметить что названия разрастаются.

Существует другой способ. Мы пишем классы в таком виде в каком нам удобно. Они могут дублироваться, но главное чтобы они были в разных файлах. После прогона бандлера, правильно настроенного, получается:

![image](<./images/Pasted image 20240222110247.png>)

т.е. берутся хеши по содержанию файла.

Причем в режиме разработки можно благодаря настройкам сделать читаемые селекторы:

![image](<./images/Pasted image 20240222110452.png>)

Чтобы typescript понимал css модули необходимо добавить декларацию типов:
```
declare module '*.module.scss' {

  interface IClassNames {

    [className: string]: string

  }

  const classNames: IClassNames;

  export = classNames;

}
```

Чтобы css модули начали работать никаких дополнительных действий в вебпаке проводить не надо, но если нужно как-то кастомизировать, то сборку настроить придется.

### Роутинг

Установка:

`npm i react-router-dom`

Поскольку у нас роутинг клиентский т.е. он работает за счет History api, но нужно разрешить в вебпаке его использование. Это работает только для dev сервера, если раздавать статику через nginx, то надо делать проксирование на index.

### Bundle analyzer

Для того чтобы следить за бандлом, сколько весить определенная библиотека, какой процент от размера бандла это все занимает, есть специальный webpack plugin - webpack bundle analyzer.

`npm i webpack-bundle-analyzer`

### Алиасы

Сейчас все импорты в проекте указаны с помощью относительных путей. Это не всегда бывает удобно, особенно, когда много вложенных директорий. Это проблему помогают решать абсолютные импорты.

### Ассеты

Для того чтобы webpack мог работать с картинками, нужно подключить соответствующий плагин. Его устанавливать не надо а просто настроить лоадер.
Причем порядок расположения лоадера не важен поскольку нет других лоадеров обрабатывающих такие же файлы.

```
const assetLoader = {

    test: /\.(png|svg|jpg|jpeg|gif)$/i,

    type: 'asset/resource'

  }
```

Для того чтобы работать с svg как с реакт компонентами, нужно установить svgr/webpack лоадер.

`npm i @svgr/webpack`

### Переменные сборки

Для того чтобы использовать глобальные переменные которые задаются при запуске проекта, т. е. достаются из env или передаются в командной строке,  нужно подключить DefinePlugin. Также следует отменить, что эти переменные нужно особым образом выделять, чтобы разработчики понимали откуда берется эта переменная. Например : `__PLATFORM__`.

Переменные сборки могут быть полезны в тех случаях, когда для разных платформ используется разные интерфейсы и тем самым webpack не грузить одновременно сразу код для двух платформ. 

### Three shaking

В вебпаке много различных встроенных оптимизаций и как раз оптимизация приведенная выше называется Tree shaking, т.е. те части кода которые не будут использоваться он из сборки убирает.

### Проверка типов в отдельном процессе

Сейчас сборка проходит за 5-6 секунд, хотя у нас проект полу пустой. Также следует отметить, что на каждую ts ошибку сборка будет падать, что не есть хорошо. Типы мы можем проверять как-то отдельно с помощью скрипта который запускается на ts-node. Вот эта проверка типов сборку очень сильно замедляет, особенно если проект большой и типов много. 

Вообще нужно понимать, что каждое действие в вебпаке, добавление нового плагина, лоадера это всегда будет сказываться на времени сборки, а в больших проектах это очень критично. Но есть решение в tsloader есть специальный флажок transpileOnly, который говорить tsloader выполнять только сборку, т.е. проверку типов он выполнять не будет.

Для того, чтобы выполнять проверку типов в отдельном процессе, тем самым не замедляя сборку есть плагин: ForkTsCheckerPlugin.

```
npm i fork-ts-checker-webpack-plugin
```

### Hot module replacement

Сейчас у нас в режиме разработки при каком-либо изменении в коде страница полностью перезагружается тем самым слетают все состояния в странице.

Например мы открыли модалку, что-то изменили в коде, потом страница полностью перезагрузилась, состояния модального окна слетела и она закрылась.

Для решения это проблемы есть HMR, который обновляет код без перезагрузки страницы, но он не будет работать с фреймворками, поэтому нужно подключить дополнительный плагин.

```
npm i -D @pmmmwh/react-refresh-webpack-plugin
```
и еще плагин, чтобы он работал с ts
```
npm i react-refresh-typescript
```

### CopyPlugin

Как в сборку перемещать дополнительные файлы? Допустим у нас есть переводы, т.е. json файлы. И чтобы сборка эти файлы видела их надо как-то переместить в папку build.
Для решения этой проблемы существует плагин:

```
npm i -D copy-webpack-plugin
```

### Полезные ссылки

[Базовая настройка webpack](https://habr.com/ru/articles/514838/)
